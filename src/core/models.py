"""Pydantic models for structured data contracts across the application.

This module defines the data models used throughout the application to ensure
consistent data contracts between components. The models are organized into
tooling models and NLP pre-processing models.
"""

from typing import List, Optional, Literal
from pydantic import BaseModel, Field

# --- Tooling Models ---


class DeviceInfo(BaseModel):
    """Data model for a single network device.

    Attributes:
        name (str): The unique name identifier for the device.
        hostname (str): The IP address or hostname for connecting to the device.
        role (Optional[str]): The role of the device in the network (e.g., 'access', 'distribution').
        device_type (str): The Netmiko device type (e.g., 'cisco_ios', 'cisco_xr').
    """

    name: str = Field(..., description="The name of the device.")
    hostname: str = Field(..., description="The IP address or hostname.")
    role: Optional[str] = Field(
        None, description="The role of the device in the network."
    )
    device_type: str = Field(
        ..., description="The Netmiko device type (e.g., cisco_ios)."
    )


class CommandOutput(BaseModel):
    """Structured output for a network command.

    Attributes:
        device_name (str): The name of the device the command was run on.
        command (str): The command that was executed.
        output (str): The raw, sanitized output from the device.
        status (str): Status of the command execution ('success' or 'error').
        error_message (Optional[str]): Details if an error occurred during execution.
    """

    device_name: str = Field(..., description="The device the command was run on.")
    command: str = Field(..., description="The command that was executed.")
    output: str = Field(..., description="The raw, sanitized output from the device.")
    status: str = Field("success", description="Either 'success' or 'error'.")
    error_message: Optional[str] = Field(
        None, description="Details if an error occurred."
    )


# --- NLP Pre-processing Models ---


class ExtractedEntities(BaseModel):
    """Represents the entities extracted from the user's query.

    Attributes:
        device_names (Optional[List[str]]): A list of device hostnames extracted from the query.
        interfaces (Optional[List[str]]): A list of interface names extracted from the query.
        protocols (Optional[List[str]]): A list of networking protocols extracted from the query.
        keywords (Optional[List[str]]): Other key terms extracted from the query.
    """

    device_names: Optional[List[str]] = Field(
        None, description="A list of device hostnames, like ['S1', 'core-router-gnmi']"
    )
    interfaces: Optional[List[str]] = Field(
        None, description="A list of interface names, like ['GigabitEthernet0/1']"
    )
    protocols: Optional[List[str]] = Field(
        None, description="A list of networking protocols, like ['BGP', 'OSPF']"
    )
    keywords: Optional[List[str]] = Field(
        None, description="Other key terms like 'flaps', 'errors', 'config'"
    )


class UserIntent(BaseModel):
    """The structured representation of a user's request, generated by the NLP layer.

    This model represents the output of the NLP pre-processing step, containing
    the user's intent, extracted entities, and additional metadata about the request.

    Attributes:
        query (str): The original, unmodified user query.
        intent (Literal): The primary goal of the user (e.g., 'get_status', 'get_config').
        entities (ExtractedEntities): All named entities recognized in the query.
        sentiment (Literal): The inferred urgency of the user's request ('normal', 'urgent', 'critical').
        is_ambiguous (bool): True if the query is unclear or lacks necessary information.
    """

    query: str = Field(..., description="The original, unmodified user query.")
    intent: Literal[
        "get_status",
        "get_config",
        "find_device",
        "troubleshoot",
        "greeting",
        "unknown",
    ] = Field(..., description="The primary goal of the user.")
    entities: ExtractedEntities = Field(
        ..., description="All named entities recognized in the query."
    )
    sentiment: Literal["normal", "urgent", "critical"] = Field(
        "normal", description="The inferred urgency of the user's request."
    )
    is_ambiguous: bool = Field(
        False,
        description="True if the query is unclear or lacks necessary information.",
    )
